

def isPalindrome(x):
    return x == x[::-1]

# Recursive function to find all palindromic partitions of str[start..n-1]
# allPart --> A vector of vector of strings.
# Every vector inside it stores a partition 
# currPart --> A vector of strings to store current partition
def allPalPartUtil(allPart, currPart, start, n, string):
    
    # If 'start' has reached len
    if start >= n:
        # In Python list are passed by reference
        # that is why it is needed to copy first
        # and then append
        x = currPart.copy()

        print(x)

        allPart.append(x)
        return

    # Pick all possible ending points for substrings
    for i in range(start, n):

        # If substring str[start..i] is palindrome
        if isPalindrome(string[start:i+1]):

            # Add the substring to result
            currPart.append(string[start: i+1])

            # Recur for remaining substring
            allPalPartUtil(allPart, currPart, i+1, n, string)

            # Remove substring str[start....i] from current partition
            currPart.pop()


# Function to print all possible
# palindromic partitions of str.
# It mainly creates vectors and
# calls allPalPartUtil()
def allPalPartitions(string):

    n = len(string)
    # To Store all palindromic partitions
    allPart = []
    # To store current palindromic partition
    currPart = []

    # Call recursive function to generate
    # all partitions and store in allPart
    allPalPartUtil(allPart, currPart, 0, n, string)

    # Print all partitions generated by above call
    for i in range(len(allPart)):
        for j in range(len(allPart[i])):
            print(allPart[i][j], end = " ")
        print()

string = 'nitin'
allPalPartitions(string)